package interviewBit;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

/**
 * 
 * Given a string, find if there is any sub-sequence that repeats itself.
A sub-sequence of a string is defined as a sequence of characters generated by deleting some characters in the string without changing the order of the remaining characters.

Input: 
string

Output:

0/1
0 -> No
1 -> Yes 
Example:

abab ------> yes, ab is repeated. So, return 1. 
abba ------> No, a and b follow different order. So, return 0. 
NOTE : sub-sequence length should be greater than or equal to 2

 * @author mrincodi
 * 2016-10-20
 * Comment: See 
 * http://www.geeksforgeeks.org/repeated-subsequence-length-2/
 * This solution is totally different (and much simpler IMO) than InterviewBit's.
 * No one told me not to use HashMaps. :) Also, we're not being asked the length of
 * the longest common subsequence; just if it exists.
 * BTW, InterviewBit's solution is not clear to me.
 */
public class RepeatingSubSequence {
	public int anytwo(String a) {

		HashMap <Character, ArrayList <Integer>> pos = 
				new HashMap <Character, ArrayList <Integer>> ();

		for ( int i = 0; i < a.length (); i++) {
			char c = a.charAt(i);
			if ( pos.containsKey(c) ) pos.get(c).add(i);
			else pos.put(c,new ArrayList <Integer>(Arrays.asList(i)));
			if ( pos.get(c).size() == 3 )return 1;
		}

		//Remove single characters.
		Set <Character> keysBefore = new HashSet  <Character> (pos.keySet());
		Iterator <Character> iter = keysBefore.iterator();

		while ( iter.hasNext() ){
			char c = iter.next();
			if (pos.get(c).size()==1) pos.remove(c);
		}	    
		//Now, find the initial pair of characters.
		iter = pos.keySet().iterator();

		while (iter.hasNext()){
			char c1 = iter.next();
			int pos1 = pos.get(c1).get(0);
			int pos2 = pos.get(c1).get(1);

			Iterator <Character> iter2 = pos.keySet().iterator();
			while ( iter2.hasNext ()){
				char c2 = iter2.next();
				if (c2 == c1 ) continue;
				int numPositions=pos.get(c2).size();
				int pos3 = pos.get(c2).get(numPositions-2);
				int pos4 = pos.get(c2).get(numPositions-1);

				if ( pos4 > pos2 && pos3 > pos1 ) return 1;
			}
		}
		return 0;
	}


	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
